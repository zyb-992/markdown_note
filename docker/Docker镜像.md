# Docker镜像

1. 拉取镜像时 首先从本地仓库查询是否有该镜像 否则会从Docker的默认共有仓库Docker Hub上查询 没有则返回错误 有则下载到本地再从本地拉取 
2. Docker镜像由文件系统叠加而成
3. 使用**联合加载**的模式加载每一层镜像的数据 一次同时加载多个文件系统 但是在外面看起来只看到一个文件系统 联合加载会将各层文件系统叠加到一起 这样最终的文件系统会包含所有底层的文件和目录
4. 当一个镜像启动容器时 Docker会在该镜像的最顶层加载一个读写文件系统 在Docker中运行的程序就是在这个读写层中执行的
5. **写时复制**：当Docker第一次启动一个容器时 初始读写层为空 当文件系统发生变化时 这些变化都会应用到这一层上 （例如修改一个文件时 该文件首先会从读写层下面的只读层复制到读写层 **文件的只读版本依然存在 但已经被读写层中的该文件副本所隐藏** 每个只读镜像层都是只读的 并且以后永远不会发生变化 
6. Docker创建新容器时 先构建出一个镜像栈 并在栈的最顶端添加读写层 下层所有的镜像层都是只读的 由镜像层与读写层以及一些配置数据(Dockerfile) 就构成了容器
7. 本地镜像保存在宿主机的`/var/lib/docker`目录下   每个镜像都保存在Docker采用的存储驱动目录下面 如aufs/devicemaper
8. 镜像保存在仓库中 每个仓库可以保存很多镜像 镜像仓库包括镜像、层、以及镜像的元数据
9. Docker Hub有两种类型仓库
   1. 用户仓库 User Repository
      1. 由Docker用户私人创建
      2. 命名：用户名 / 仓库名
      3. **在Docker Client中登录Docker Hub时 个人信息会保存到$HOME/.dockercfg中**
   2. 顶层仓库 Top-level Repository
      1. 由Docker内部人员管理
      2. 命名：仓库名
10. 使用Dockerfile构建镜像
    1. 通过Dockerfile以及docker build构建镜像
    2. 创建目录 保存dockerfile
    3. 目录是我们的构建环境 Docker称此环境为**上下文/构建上下文**
    4. Docker会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker的守护进程 这样Docker守护进程能直接访问想在镜像中存储的任何代码、文件及其他数据
    5. **Dockerfile中每条命令都会新创建出一个镜像层并对镜像进行提交**
       1. 大致流程
          - Docker从基础镜像运行一个容器
          - 执行一条指令 对容器进行修改
          - 执行类似docker commit操作 提交新的镜像层
          - Docker基于刚提交的镜像运行于一个新容器
          - 执行Dockerfile的下一条指令 回到开始(Docker从基础镜像运行一个容器) 直到所有指令执行完毕
    6. 运行多个容器时 多个容器不能同时绑定的宿主机的同个端口上
       - 运行docker run时 指定`-P`参数可以用来对外公开在Dockerfile中的EXPOSE指令中设置的所有端口
    7. 运行自己的Docker Registry
       1. 希望构建和存储不想被公开的信息或数据的镜像
          - 利用Docker Hub上的私有仓库
          - 在防火墙后运行你自己的Registry
       2. **在防火墙后运行你自己的Registry**
          1. docker run registry
          2. 启动一个运行Registry应用的容器 

