# 内核态/用户态

1. 什么时候会陷入内核态？
   - 系统调用
     - `open/kill/mkdir`等函数
   - 异常
     - 例如CPU此时读取的一个进程中的某一页并未在内存中 而是在虚拟内存(硬盘中 则需要进行页面置换，就到了处理异常的内核相关程序中，也就到了**内核态**
   - 外部设备的中断
2. 用户态到内核态切换的途径
   1. 操作系统一般都是通过**中断**来从用户态切换到内核态
      1. **将处理器状态寄存器PSR的CPL位置0(内核级)** 即可切换到内核态

![](D:\Program Files\电子书\go\md\图片\image-20220910111234164.png)

# 中断

1. 中断的属性
   1. 中断号
   2. 中断处理程序
   
2. 不同的中断号拥有不同的中断处理程序

3. **中断向量表**
   1. 当CPU某个核执行到中断时，会对当前进程执行上下文保存
   2. 然后根据该中断的中断号去到内核中维护的中断向量表进行对应的中断处理程序并调用
   3. 中断完成后 恢复并继续执行之前进程
   
4. 中断的两种类型
   1. **软中断**（调用中断指令）：指令级别，使用这条指令用户可以手动触发某个中断
      - 对应系统调用来说 因为中断号有限 因此不可能一个中断对应于一个系统调用程序 所以在中断执行时 **系统调用在中断向量表中的值为0x80** 用0x80来触发所有的系统调用 然后对于每一个系统调用程序都有对应的一个系统调用号 **在触发中断之前 会将系统调用号放入到一个固定的寄存器中** 0x80的中断处理程序会在执行过程中读取该寄存器的值 再决定执行系统调用的代码
   2. **硬中断**（外设通过硬件中的中断驱动发出中断信号给CPU）：直接由硬件给出相关数据，无需占用CPU时间
      - 硬件中断是由系统相连的外设(网卡 硬盘 键盘)发出的
      - 处理中断的驱动是需要运行在CPU上的，因此当中断产生时 CPU会暂时停止当前程序的程序转而执行中断请求，一个中断只能中断一颗CPU(也有一种特殊情况，就是在大型主机上是有硬件通道的, 它可以在没有主CPU的支持下, 同时处理多个中断)
   
   

# 虚拟内存

**CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。**

![](D:\Program Files\电子书\go\md\图片\image-20220910113327796.png)



## **页表**

- **一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。**

- 每个进程都有自己对应的页表

- 页表元素——**页表项的结构**

  - `访问位`  
  - `修改位` 在内存中修改该页或将数据写入该页时（即它是“脏”的) 则后面必须把它写回磁盘中 对操作系统来说 进行页面置换时优先置换脏页
  - `保护位` 一个页面允许什么类型的访问
    - 0表示读写
    - 1表示只读
  - `“在/不在”位` 

  ![](D:\Program Files\电子书\go\md\图片\image-20220910154348793.png)

- 若某个页面不在内存中 能确认的是用于保存该页面的磁盘地址不是页表的组成部分 **页表是存储那些在内存中的页面的项**

- 针对大内存的机器来说 我们可以采用**多级页表**（加速分页查询过程

  - 多级页表

    - 引入多级页表是为了节省内存 避免把全部页表项都一直保存在内存中 因为有些页表的页表项在程序运行过程中是一直没有用到的  
    - 对于32位机器来说 32位的虚拟地址被划分为10位的PT1域，10位的PT2域以及12位的偏移量(代表页面容量为4kb)，当一个虚拟地址被送往MMU时，首先解析高10位，分析出其是**顶级页表**中的哪一项，再从顶级页表的该项中得到二级页表号，然后分析该虚拟地址的PT2域，即可得到二级页表中对应的页表项 以此得到物理内存的页框号 然后该物理页框号与偏移量结合得到内存中实际的物理地址 将该地址放到地址总线中被送到内存中

    ![](D:\Program Files\电子书\go\md\图片\image-20220910171353994.png)

    

### **地址翻译过程（将虚拟内存映射到物理内存）**

1. 当CPU切换到某个进程执行时 会将该进程的页表在内存中的起始地址载入**页表基址寄存器(PTBR)**
2. 假设操作系统中一个虚拟页面为4kb 设虚拟地址由n位地址组成 
   - 64位操作系统页表的虚拟页偏移量普遍设置为4kb(2^12)  虚拟页号就等于2^(n-12)
   - 虚拟页偏移量=物理页偏移量
   - 物理页号等于2^(m-12)  物理页号也称为**页框号** 
     - 同时页框数量应该远远大于虚拟页号 即m>>n 因为实际内存应该大于单个进程的虚拟内存
   - CPU从需要取值的虚拟地址中的后(p->n-1)位取出虚拟页号 检查该值在页表中对应的行的有效位是0还是1 （这里的p=12）
     - 1表示该页装载在内存中 那么此时从该行中取出物理页号 即页框号 然后加上虚拟页偏移量 就得到了对应的地址
     - 0表示该页此时不在内存中 此时则**需要进入内核态**  此时CPU发生**缺页异常** 进入对应的中断 **进行页面装载 或 页面置换 将该置换装到内存中** 然后从该行中取出物理页号 即页框号 然后加上虚拟页偏移量 就得到了对应的地址
3. TLB是什么？它是如何工作的
   1. `TLB` 全称 `Translation Lookaside Buffer` **转换检测缓冲区** 也称为**相联存储器**或**快表**
   2. 它通常存储在MMU中 包含少量的表项
   3. TLB的每个表项记录了一个页面的相关信息，包括虚拟页号、页面修改位、保护码（读/写/执行权限）和该页对应的物理页框（其中虚拟页号在当前不是必须存储在页表中 例如当在TLB查找到某页时 但在此之前已被交换出内存 那么此时就会执行页面装载 并将该页表项同时装入TLB中
4. 设置TLB是为了加速地址翻译的过程

![](D:\Program Files\电子书\go\md\图片\image-20220910141548144.png)



### 页面置换算法

- 最近未使用页面置换算法 **NRU**

  - R位：页表项的访问位
  - M位：页表项的修改位

  ![](D:\Program Files\电子书\go\md\图片\image-20220910175314391.png)

  ![](D:\Program Files\电子书\go\md\图片\image-20220910174644510.png)

-  先进先出页面置换算法

  - 操作系统维护一个所有当前在内存中的页面的链表 最新进入的页面放在表尾 最早进入的页面放在表头 
  - 当发生缺页中断时 淘汰表头的页面并把新调入的页面加到队尾

- 第二次机会页面置换算法

  - FIFO算法可能会把经常使用的页面置换出去 为了避免该问题 做一个简单修改
  - 检查最老页面的R位 
    - 若R位是0 那么可以将其置换掉
    - 如果R位是1 则将R位清0 并把页面放入链表尾端 就相当于它是刚刚被装入内存中访问的页面

- 最近最少使用页面置换算法 **LRU**

  ![](D:\Program Files\电子书\go\md\图片\image-20220910180231738.png)

