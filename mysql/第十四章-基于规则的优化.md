# 基于规则的优化

## 条件化简

- 移除不必要的括号

  ```mysql
  SELECT * FROM (t1, (t2, t3)) WHERE t1.a=t2.a AND t2.b=t3.b;
  ```

- 常量传递

  ```mysql
  a = 5 AND b > a
  # -> 修改
  a = 5 AND b > 5
  ```

- 移除没用的条件：移除永远为TRUE或FALSE的表达式

  ```mysql
  (a < 1 AND b = b) 
  ```

- 表达式计算

  ```mysql
  a = 5+1
  ```

- HAVING子句和WHERE子句的合并

## 外连接消除

- 在WHERE子句中的搜索条件中指定"被驱动表的列不为NULL"的搜索条件，那么外连接中在被驱动表中找不到符合ON子句条件的驱动表记录也就不会出现在最终的结果集中
- 指定的WHERE子句中包含被驱动表中的列不为NULL值的条件称为**空值拒绝**

## 子查询优化

### 按返回结果集区分子查询

- 标量子查询
- 行子查询
- 列子查询
- 表子查询

### 按与外层查询的关系来区分子查询

- **不相关子查询**：子查询可以单独运行出结果，不依赖于外层查询的值

- **相关子查询**：子查询的执行需要依赖于外层查询的值

  ```mysql
  # n1存在于t1中
  SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
  ```



## 子查询在MySQL中是怎么执行的

### 不相关子查询

1. 单独执行子查询语句
2. 将子查询得到的结果作为外层查询的参数，再执行外层查询

### 相关子查询

1. 先从外层查询获取一条记录
2. 从该记录中找出子查询中涉及的列，代入执行子查询
3. 根据子查询的查询结果来检测外层查询WHERE子句的条件是否成立，若成立则把外层查询的那条记录加入到结果集，否则丢弃
4. 重复执行步骤1，以此类推

### IN子查询优化

> 对于IN子查询，可能结果集太多，内存放不下，同时外层查询无法有效使用索引

#### 基于内存和磁盘的优化

- 将IN子查询的结果集写入临时表中
  - 该临时表的列就是子查询结果集中的列
  - 写入临时表的记录会被去重(建立主键或者唯一索引)

- 内存：使用MEMORY存储引擎的临时表，会为该表简历哈希索引
- 磁盘：为该临时表建立B+树索引
- 如果子查询结果集超过了系统变量`tmp_table_size`或者`max_heap_table_size`的值，临时表会转而使用磁盘的存储引擎来保存结果集中的记录，索引类型也相应的转变为B+树索引

#### 物化表

- **物化**：将子查询结果集中的记录保存到临时表的过程

##### 物化表转连接



### 半连接

- 对驱动表的某条记录，只关心在被驱动表中是否存在与之匹配的记录，而不关心具体由多少条记录与之匹配，最终结果集中只保留驱动表的记录

##### 实现半连接

- Table pullout（子查询表上拉
- Duplicate Weedout（重复值消除
- LooseScan（松散扫描



